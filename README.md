

## Упрощение схемы

Предположим, что схема подается в *BENCH* формате. Какие поддерживаются упрощения: 
- Если имеется гейт AND которому на вычисляющий AND двух одинаковых гейтов, то заменяется на `x = EQ(y)` вместо `x = AND(y, y)`
- гейт XOR двух одинаковых гейтов, заменяется на гейт ZERO, после применяя к нему отрицание можно получить и гейт ONE. У таких типов гейтов нет родителей.
- Если имеется гейт OR, у которого на вход есть ONE, то понятно, как упрощается гейт: заменяется на ONE.
- Также, если имеется гейт у которого все входы - ONE / ZERO, то гейт автоматически считается той константой которая получится.
### Эти четыре улучшения делаются одним поиском в глубину, следовательно за `O(n)`, но появляются бесполезные гейты `x = EQ(y)`
- Есть функция `dfs_unused(...)`, которая запускает поиск в глубину начиная с принимающего гейта, и удаляет недостижимые гейты, в то числе инпуты.

- Например, схема (test1.bench):
```
INPUT(1) 
INPUT(2)
INPUT(3)
INPUT(4)
INPUT(5)
OUTPUT(8)
6 = OR(1, 2)
7 = AND(2, 3)
8 = XOR(6, 7)
9 = OR(4, 5)
10 = NOT(9)
```
Как несложно видеть, преобразуется в (Это такой мой вымышленный формат: назвение гейта, операция, родители):
```
8, Op.XOR, ['6', '7']
1, Op.INPUT, ['1']
2, Op.INPUT, ['2']
3, Op.INPUT, ['3']
6, Op.OR, ['1', '2']
7, Op.AND, ['2', '3']
```
Удалились недостижимые гейты. 

Другая схема (test2.bench)
```
INPUT(1)
INPUT(2)
INPUT(3)

OUTPUT(6)
4 = AND(1, 2)
5 = XOR(3, 3)
6 = AND(4, 5)
```
несложно видеть, что ответ не зависит от входа, поэтому после поиска в глубину появятся константы а после незатронутые гейты удалятся, и останется (не зависит от входов), ответ всегда 0
```
6, Op.ZERO, []
```

Запускать нужно `main.py`, поменять путь к файлу. По дефолту, там запускается упрощение (вычисление и как бы проталкиание констант) и удаление недостежимых гейтов. Выводится все в вымышленном, но вроде понятном формате 
